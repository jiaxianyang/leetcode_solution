//给定一个正整数 n，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中 设置位 的个数（也被称为汉明重量）。 
//
// 
//
// 示例 1： 
//
// 
//输入：n = 11
//输出：3
//解释：输入的二进制串 1011 中，共有 3 个设置位。
// 
//
// 示例 2： 
//
// 
//输入：n = 128
//输出：1
//解释：输入的二进制串 10000000 中，共有 1 个设置位。
// 
//
// 示例 3： 
//
// 
//输入：n = 2147483645
//输出：30
//解释：输入的二进制串 1111111111111111111111111111101 中，共有 30 个设置位。 
//
// 
//
// 提示： 
//
// 
// 1 <= n <= 2³¹ - 1 
// 
//
// 
// 
//
// 
//
// 进阶： 
//
// 
// 如果多次调用这个函数，你将如何优化你的算法？ 
// 
//
// Related Topics 位运算 分治 👍 668 👎 0

package com.rj.leetcode_solution.leetcode.editor.cn;
//java:位1的个数
class P191NumberOf1Bits{
    public static void main(String[] args){
        Solution solution = new P191NumberOf1Bits().new Solution();
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int hammingWeight(int n) {

//        表达式 (n & (1 << i)) != 0 用于检查整数 n 的第 i 位是否为 1。以下是对这个表达式的详细解释：
//
//        解释
//        1 << i：
//
//        这是一个位移操作，表示将数字 1 左移 i 位。
//        左移操作会在二进制表示中向左移动位数，并在右侧用 0 填充。
//        例如，1 << 2 将 1（即 0001）左移两位，结果是 0100，即十进制的 4。
//        n & (1 << i)：
//
//& 是按位与运算符。它逐位比较两个数的二进制表示，并在两个对应位都为 1 时返回 1，否则返回 0。
//        通过 n & (1 << i)，我们可以只关注 n 的第 i 位，因为 (1 << i) 只有第 i 位是 1，其余位都是 0。
//!= 0：
//
//        这个条件检查 n & (1 << i) 的结果是否不等于 0。
//        如果结果不等于 0，说明 n 的第 i 位是 1。
//        示例
//        假设 n = 10 和 i = 1：
//
//        n 的二进制表示是 1010。
//        1 << 1 的结果是 0010。
//        进行按位与运算：1010 & 0010 = 0010。
//        0010 不等于 0，所以 (n & (1 << i)) != 0 为 true，表示 n 的第 1 位是 1。
//        再举一个例子，假设 n = 10 和 i = 2：
//
//        n 的二进制表示是 1010。
//        1 << 2 的结果是 0100。
//        进行按位与运算：1010 & 0100 = 0000。
//        0000 等于 0，所以 (n & (1 << i)) != 0 为 false，表示 n 的第 2 位不是 1。
//        这种方法常用于检查某个特定位是否被设置为 1，是位操作中常用的技巧之一。

//        int count = 0;
//        for (int i = 0; i < 32; i++) {
//            if ((n & (1 << i)) != 0) {
//                count++;
//            }
//        }
//        return count;


//        这段代码用于计算整数 n 的二进制表示中有多少个 1（即计算 n 的汉明重量或称为“人口计数”）。让我们逐步解释这段代码：
//
//        代码解释
//        初始化：
//
//        int ret = 0;：初始化计数器 ret，用于记录 n 中 1 的个数。
//        循环条件：
//
//        while (n != 0): 只要 n 不为零，继续循环。这意味着只要 n 中还有 1，循环就会继续。
//        核心操作：
//
//        n &= n - 1;：这是一个关键操作，用于将 n 中的最低有效位的 1 清零。
//        n - 1 会将 n 的最低有效位的 1 变为 0，并将它右侧的所有位变为 1。
//        n &= n - 1 会将 n 的最低有效位的 1 清零。
//        例如，假设 n = 6，即 110：
//        n - 1 为 5，即 101。
//        n & (n - 1) 为 110 & 101 = 100，即 4。
//        这个操作每执行一次，就会清除掉 n 中的一个 1。
//        计数：
//
//        ret++;：每次清除一个 1，计数器 ret 增加 1。
//        返回结果：
//
//        return ret;：返回 ret，即 n 中 1 的个数。
//        整体流程
//        每次循环通过 n &= n - 1 清除掉 n 中的一个 1，直到 n 变为 0。
//        ret 记录了清除 1 的次数，也就是 n 中 1 的总数。
//        这个算法的效率很高，因为它的时间复杂度是 O(k)，其中 k 是 n 中 1 的个数，而不是 O(log n) 或 O(n)（n 是位数），这使得它在处理大整数时非常高效。

        int ret = 0;
        while (n != 0) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}