//给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。 
//
//
// 
//
// 
// 
// 示例 1： 
// 
// 
//
// 
//输入：n = 2
//输出：[0,1,1]
//解释：
//0 --> 0
//1 --> 1
//2 --> 10
// 
//
// 示例 2： 
//
// 
//输入：n = 5
//输出：[0,1,1,2,1,2]
//解释：
//0 --> 0
//1 --> 1
//2 --> 10
//3 --> 11
//4 --> 100
//5 --> 101
// 
//
// 
//
// 提示： 
//
// 
// 0 <= n <= 10⁵ 
// 
//
// 
//
// 进阶： 
//
// 
// 很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？ 
// 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ） 
// 
//
// Related Topics 位运算 动态规划 👍 1372 👎 0

package com.rj.leetcode_solution.leetcode.editor.cn;

import com.sun.org.apache.bcel.internal.generic.NEW;

//java:比特位计数
class P338CountingBits{
    public static void main(String[] args){
        Solution solution = new P338CountingBits().new Solution();
    }
    //leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int[] countBits(int n) {

//        代码解释：
//        初始化数组：bits数组长度为n+1，存储每个数对应的1的个数。
//
//        维护最高位：变量highBit记录当前最高位的2的幂（如1, 2, 4, 8等）。
//
//        遍历计算：
//
//        判断2的幂：(i & (i-1)) == 0时，说明i是2的幂（如i=4的二进制是100，i-1=011，相与结果为0）。
//
//        更新最高位：当i是2的幂时，更新highBit为当前i。
//
//        递推计算：bits[i] = bits[i - highBit] + 1。当前数的1的个数等于去掉最高位后的数的1的个数加上当前最高位的1。
//
//        示例分析（以n=5为例）：
//        i=1：是2^0，highBit=1，bits[1] = bits[0]+1 = 1（二进制：1）。
//
//        i=2：是2^1，highBit=2，bits[2] = bits[0]+1 = 1（二进制：10）。
//
//        i=3：非2的幂，bits[3] = bits[1]+1 = 2（二进制：11）。
//
//        i=4：是2^2，highBit=4，bits[4] = bits[0]+1 = 1（二进制：100）。
//
//        i=5：非2的幂，bits[5] = bits[1]+1 = 2（二进制：101）。
//
//        最终结果：[0, 1, 1, 2, 1, 2]。
//
//        关键点：
//        动态规划：利用已计算结果避免重复计算。
//
//        位运算优化：快速判断2的幂，高效更新最高位。
//
//        时间复杂度：每个数只需O(1)时间，整体O(n)。

//        这段代码中的递推式 bits[i] = bits[i - highBit] + 1 利用了二进制的特性，通过动态规划高效计算每个数的1的个数。以下是逐步解释：

//        核心思路
//        二进制数的结构：
//        任何整数 i 的二进制可以表示为 最高位的1 + 剩余部分。例如：
//
//        i = 5（二进制 101）= 最高位的 100（4） + 剩余部分的 1（1）
//
//        i = 7（二进制 111）= 最高位的 100（4） + 剩余部分的 11（3）
//
//        递推关系：
//        当前数 i 的1的个数 = 剩余部分的1的个数 + 最高位的1个1。
//        因此，若已知剩余部分（i - highBit）的1的个数，只需加1即可得到 i 的1的个数。
//
//        关键步骤解析
//        维护最高位 highBit：
//
//        当 i 是2的幂（如1, 2, 4, 8...）时，更新 highBit = i。
//
//        例如：i=4 时，highBit 更新为4，因为4是当前最大的2的幂。
//
//        递推公式 bits[i] = bits[i - highBit] + 1：
//
//        i - highBit：去掉当前最高位后的剩余部分。
//
//        bits[i - highBit]：剩余部分对应的1的个数（已提前计算）。
//
//        +1：加上最高位的1。
//
//        具体例子分析
//        以 i = 5 为例：
//
//        确定 highBit：
//
//        最大的2的幂 ≤5 是 4（highBit=4）。
//
//        计算剩余部分：
//
//        i - highBit = 5 - 4 = 1。
//
//        递推计算：
//
//        bits[5] = bits[1] + 1 = 1 + 1 = 2（二进制 101 确实有2个1）。
//
//        为什么 highBit 是动态更新的？
//        2的幂的判断：当 (i & (i-1)) == 0 时，i 是2的幂。
//
//        例如：i=8 的二进制是 1000，i-1=0111，相与结果为 0000。
//
//        更新意义：确保 highBit 始终是当前最大的2的幂，从而正确分割最高位和剩余部分。
//
//        时间复杂度与空间复杂度
//        时间复杂度 O(n)：每个数只需一次计算。
//
//        空间复杂度 O(n)：存储结果数组 bits。
//
//        总结
//        递推式通过将数分解为 最高位的1 和 剩余部分，利用已计算的剩余部分结果，高效避免了重复计算。这种动态规划结合位运算的方法，是处理二进制问题的经典技巧。

        int[] bits = new int[n + 1];
        int highBit = 0;
        for (int i = 1; i <= n; i++) {
            if ((i & (i - 1)) == 0) {
                highBit = i;
            }
            // 1 的 个数 等于 最高位 + 剩余部分，那么当前i  1 的 个数， 等于 剩余部分  + 1
            bits[i] = bits[i - highBit] + 1;
        }
        return bits;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}